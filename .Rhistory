library(MASS)
source("./eq_tests.R")
#=========================================================================
# Population dynamics implemented numerically with reciprocal invasions
#=========================================================================
#########
#Tunable
#########
ngens=16000 #Number of generations 
mFr=matrix(c(5,5))   #Mean reproduction rates
sig_Fr= matrix(c(1, -1, -1, 1),2,2) #Covariance matrix
alphas=matrix( c(0.5,0.5),2,1) #competitive interactions
sr=0.9 #Survival
#Invasion times (divide into quarters is the easiest)
invasions =c(1, floor(ngens/4), floor(ngens/2), floor(ngens*3/4) )
#########
#Internal
#########
Fr=abs(mvrnorm(ngens,mFr,sig_Fr)) #Take the abs value of correlated normal
#Standardize values between 0 and 1 based on maximum.
Fr=Fr/(matrix(apply(Fr,2,max),ngens,2,byrow=T)) 
#Population matrixes
nrns1=matrix(0,ngens,1)
nrns2=matrix(0,ngens,1)
#Exponential form of the model: 
nrns1E=matrix(0,ngens,1)
nrns2E=matrix(0,ngens,1)
nrns2[1]=0.1 #Seed species 2 and allow it to establish as resident
nrns2E[1]=0.1
for (n in 1:(ngens-1)) {
    #Invasion: Seed or set to near-zero at the appropriate time steps:
    if (n==invasions[2]) { nrns1[n]=0.0001; nrns1E[n]=0.0001  }
    #Switch the roles of resident and invader between species 1 and 2
    if (n==invasions[3]) { nrns1[n]=0.1; nrns1E[n]=0.1
                            nrns2[n]=0; nrns2E[n]=0   }
    #Second invasion
    if (n==invasions[4]) { nrns2[n]=0.0001;nrns2E[n]=0.0001 }
    #Spatially implicit annual plant model
    nrns1[n+1] = sr*(1-Fr[n,1])*nrns1[n]+Fr[n,1]*mFr[1]*nrns1[n]/(1+alphas[1]*(nrns1[n]*Fr[n,1]+Fr[n,2]*nrns2[n]))
    nrns2[n+1] = sr*(1-Fr[n,2])*nrns2[n]+Fr[n,2]*mFr[2]*nrns2[n]/(1+alphas[2]*(nrns1[n]*Fr[n,1]+Fr[n,2]*nrns2[n]))
    #Exponential form of the model
    nrns1E[n+1] = sr*(1-exp(log(Fr[n,1])))*nrns1E[n]+nrns1E[n]*mFr[1]*exp( log(Fr[n,1])- log(1+alphas[1]*(nrns1E[n]*Fr[n,1]+Fr[n,2]*nrns2E[n])))
    nrns2E[n+1] = sr*(1-exp(log(Fr[n,2])))*nrns2E[n]+nrns2E[n]*mFr[2]*exp( log(Fr[n,2])-log(1+alphas[2]*(nrns1E[n]*Fr[n,1]+Fr[n,2]*nrns2E[n])))
}
plot(nrns2,t="l")
lines(nrns1,col="red")
library(fGarch) #For GARCH models
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nens1[1:100], trace=F)
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[1:100], trace=F)
nrns[1:100]
nrns1[1:100]
nrns2[1:100]
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+100), trace=F)
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+100)], trace=F)
nrns1[invasions[2]:(invasions[2]+100)]
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+300)], trace=F)
summary(pop_garch)
plot(pop_garch@h.t)
ar(data=nrns1[invasions[2]:(invasions[2]+300)])
?ar
ar(nrns1[invasions[2]:(invasions[2]+300)])
pop_garch = garchFit( ~arma(4,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+300)], trace=F)
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+300)], trace=F)
pop_garch = garchFit( ~arma(0,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+300)], trace=F)
summary(pop_garch)
?garchFit
plot(pop_garch)
pop_garch = garchFit( ~arma(0,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+1000)], trace=F)
plot(pop_garch)
pop_garch = garchFit( ~arma(1,0)+garch(1,1), data=nrns1[invasions[2]:(invasions[2]+1000)], trace=F)
plot(pop_garch)
x=nrns1[invasions[2]:(invasions[2]+1000)]
window = 10, max.lag = 10
window = 10; max.lag = 10
    nt = length(x)
    pvals = matrix(0,nt,1) #Store the p-values
    for (t in 1:(nt-1)) { 
        pvals[t] = Box.test(x[nt:(nt+window)],lag=max.lag, type="Ljung-Box")
    }
t=1
        pvals[t] = Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box")
a1=Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box")
summary(a1)
(a1)
(a1)$p.value
for (t in 1:(nt-window)) { 
        pvals[t] = (Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value
    }
plot(pvals[t])
pvals
unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
    for (t in 1:(nt-window)) { 
        pvals[t] = unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
    }
plot(pvals)
summary(pvals)
unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value))
nt = length(x)
    pvals = matrix(0,nt,1) #Store the p-values
    for (t in 1:(nt-window)) { 
        pvals[t] = unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
    }
pvals[1:10]
plot(pvals)
window=100
nt = length(x)
    pvals = matrix(0,nt,1) #Store the p-values
    for (t in 1:(nt-window)) { 
        pvals[t] = unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
    }
plot(pvals)
pvals[1:10]
t
unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
(Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))
max.lag=25
nt = length(x)
    pvals = matrix(0,nt,1) #Store the p-values
    for (t in 1:(nt-window)) { 
        pvals[t] = unlist((Box.test(x[t:(t+window)],lag=max.lag, type="Ljung-Box"))$p.value)
    }
plot(pvals)
nt = length(x)
    dat_temp = matrix(0,nt,1) #Store the p-values
    for (t in 1:(nt-window)) {
        dat_temp[t] = mean(x[t:(t+window)]) 
    }
window
diff(dat_temp)
plot(dat_temp)
plot(diff(dat_temp))
(diff(dat_temp))[1:10]
plot(diff(dat_temp)[1:100])
plot(diff(dat_temp)[1:200])
plot(diff(dat_temp)[1:300])
plot(diff(dat_temp)[1:400])
plot(diff(dat_temp)[1:500])
max(diff(dat_temp)[1:500])
a1=splinefun(x)
plot(a1)
plot(x)
a1=splinefun(1:nt,x)
plot(a1)
plot(1:nt,a1)
length(a1)
a1
dim(a1)
summary(a1)
a1=splinefun(1:nt,x)
a1
a1=splinefun(x=1:nt,y=x)
a1
plot(a1)
a2=splinefun(x=1:nt,y=x)
a2
a2[1:10]
a1[1:10]
?splinefun
a2=splinefun(x)
a2
a2[1:10
]
rm(a1,a2)
a1
x
x1=x
a2=splinefun(x1)
a2
a2(1:10)
plot(a2(1:10))
plot(a2(1:100))
plot(a2(1:1000))
?splinefun
a2=spline(x1)
plot(a2(1:1000))
a2
plot(a2)
library(MASS)
source("./eq_tests.R")
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)])
plot(ed1)
plot(ed1[1:100)
plot(ed1[1:100])
plot(ed1[1:1000])
plot(ed1[1:300])
plot(ed1[1:400])
plot(ed1[1:500])
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)],window=3)
max(ed1)
plot(ed1[1:1000])
plot(ed1[1:300])
plot(ed1[1:300])
plot(ed1[1:400])
plot(ed1[1:500])
source("./eq_tests.R")
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)],window=3)
source("./eq_tests.R")
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)],window=3)
window
nt = length(x)
    dat_temp = matrix(0,nt,2) #Store the smooth and the difference
    for (t in 1:(nt-window)) {
        dat_temp[t,2] = mean(x[t:(t+window)]) 
    }
dim(dat_temp)
dim(diff(dat_temp))
(diff(dat_temp))[1:10,]
?diff
a1=diff(dat_temp)
plot(a1[,2])
plot(a1[,1])
dim(diff(dat_temp[,1]))
length(diff(dat_temp[,1]))
length(c(diff(dat_temp[,1]),0))
nt = length(x)
    dat_temp = matrix(0,nt,2) #Store the smooth and the difference
    for (t in 1:(nt-window)) {
        dat_temp[t,1] = mean(x[t:(t+window)]) 
    }
    dat_temp[,2]=c(diff(dat_temp[,1]),0)
source("./eq_tests.R")
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)],window=3)
plot(ed1[,1])
ed1 = eq_diff(nrns1[invasions[2]:(invasions[2]+1000)],window=100)
plot(ed1[,1])
plot(ed1[1:200,2])
plot(ed1[1:300,2])
plot(ed1[1:400,2])
plot(ed1[1:500,2])
eLB1=eq_LB(nrns1[invasions[2]:(invasions[2]+1000)], window = 100, max.lag = 10 )
plot(elB1)
plot(eLB1)
eLB1=eq_LB(nrns1[invasions[2]:(invasions[2]+1000)], window = 10, max.lag = 10 )
plot(eLB1)
plot(eLB1[1:500])
eLB1=eq_LB(nrns1[invasions[2]:(invasions[2]+1000)], window = 100, max.lag = 10 )
plot(eLB1[1:500])
eLB1=eq_LB(nrns1[invasions[2]:(invasions[2]+1000)], window = 100, max.lag = 100 )
plot(eLB1[1:500])
q()
